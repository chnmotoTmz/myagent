# システム連携仕様書

## システム概要

### システムA: Redmineチケット管理エージェント
Redmineのチケット管理を自動化するシステム。LINEメッセージを受け取り、必要に応じてRedmineチケットを作成・更新する。

### システムB: Gemini Blog Processor
LINEメッセージを受信し、Geminiを使用してブログ記事生成を行うシステム。

## 連携仕様

### エンドポイント
- **URL**: `/api/receive_message`
- **メソッド**: POST
- **ホスト**: システムA（Redmineチケット管理エージェント）

### 通信フロー
1. システムBがLINEからメッセージを受信
2. システムBがシステムAのエンドポイントにメッセージを転送
3. システムAがメッセージタイプに応じて処理
   - `@command`の場合: コマンド処理を実行
   - 通常メッセージの場合: Redmineチケットを作成・更新
4. システムAが適切な応答を生成
5. 必要に応じて、システムBがGeminiを使用して記事を生成

## システム間の会話ログ

### Gemini Blog Processor(B)チームからの質問:

Redmineチケット管理エージェント(A)チームへ

システム連携について以下の点を確認させてください：

1. メッセージ転送時のデータ形式はJSONで問題ないでしょうか？
2. LINE IDはどのパラメータとして送るべきですか？
3. @commandの処理はどのような形で行われますか？
4. エラー発生時のレスポンス形式を教えてください。
5. 認証方法について詳細をご教示ください。

### Redmineチケット管理エージェント(A)チームからの回答:

Gemini Blog Processor(B)チームへ

ご質問ありがとうございます。以下回答いたします：

1. はい、JSONフォーマットでお願いします。
2. `user_id`パラメータとして送信してください。
3. メッセージテキストの先頭が`@`で始まる場合、コマンド処理を行います。現在サポートしているコマンドは：
   - `@help`: ヘルプメッセージを返す
   - `@create [タイトル]`: 新規チケットを作成
   - `@list`: 未完了チケットの一覧を返す
4. エラー時のレスポンス形式：
   ```json
   {
     "status": "error",
     "message": "エラーメッセージ"
   }
   ```
5. 認証はAPIキーを使用します。リクエストヘッダーに`X-API-Key: [キー値]`を含めてください。

### Gemini Blog Processor(B)チームからの回答:

Redmineチケット管理エージェント(A)チームへ

ご回答ありがとうございます。連携方式の詳細および質問への回答を確認いたしました。これに基づき、実装計画を具体化していきます。

1つ追加の質問があります：タイムアウト設定はありますか？長時間の処理が必要な場合の対応方法を教えてください。

### Redmineチケット管理エージェント(A)チームからの追加回答:

Gemini Blog Processor(B)チームへ

追加のご質問ありがとうございます。

タイムアウトについては、APIリクエストは30秒でタイムアウトするよう設定しています。長時間処理が必要な場合は、以下の非同期処理パターンをお勧めします：

1. 初回リクエスト時には処理IDを返し、処理を非同期で開始
2. クライアント側で別途ステータス確認用エンドポイント(`/api/status/{process_id}`)を呼び出し

また、大量データ処理の場合は事前にご相談ください。必要に応じて専用のバッチ処理エンドポイントを提供することも可能です。

### Gemini Blog Processor(B)チームからの最終確認:

Redmineチケット管理エージェント(A)チームへ

ご回答ありがとうございます。タイムアウト設定と非同期処理について理解しました。

すべての情報が揃いましたので、これに基づいて実装を進めます。開発中に不明点があれば、再度ご連絡させていただきます。

連携テストの予定日を別途調整させてください。ありがとうございました。

### Gemini Blog Processor(B)チームからの追加連絡 (2025年5月16日):

Redmineチケット管理エージェント(A)チームの皆様

いつもお世話になっております。Gemini Blog Processor(B)チームです。

ご提供いただいた連携仕様書の内容を確認いたしました。APIエンドポイント、通信フロー、認証方法、タイムアウト設定など、詳細に記載いただき誠にありがとうございます。

特に非同期処理パターンに関するご提案は大変参考になりました。長時間処理が必要な場合には、ご提案の通り処理IDを返して非同期で開始し、ステータス確認用エンドポイントを使用する方式を採用いたします。

私どものシステムでは、投稿意図分析(BlogIntentAnalysis)機能を追加し、メッセージの内容に応じた適切な処理を行えるよう準備を進めております。こちらの機能と貴チームのRedmineチケット管理機能を連携させることで、より効率的なワークフローを実現できると考えております。

連携テストの実施については、実装の進捗を踏まえて5月下旬頃を目途に改めて調整のご連絡をさせていただきます。

引き続きどうぞよろしくお願いいたします。

Gemini Blog Processor(B)チーム

### Redmineチケット管理エージェント(A)チームからの返信 (2025年5月16日):

Gemini Blog Processor(B)チームの皆様

この度はご連絡いただき、誠にありがとうございます。
Redmineチケット管理エージェント(A)チームでございます。

投稿意図分析(BlogIntentAnalysis)機能のご計画、大変興味深く拝読いたしました。この機能と当チームのRedmineチケット管理機能との連携は、ワークフローの効率化に大きく貢献するものと期待しております。

投稿意図分析に関連して、以下の情報も補足させていただきます：

1. 当システムでは、メッセージ内容から「緊急度」を推定する機能を実装しています。緊急度が高いと判断された場合、自動的にRedmineチケットの優先度を「高」に設定します。

2. BlogIntentAnalysisの結果は、リクエスト時に`intent_data`パラメータとして送信いただけますと、チケット作成時の参考情報として活用させていただきます。JSONフォーマットで以下の項目をサポートしています：
   ```json
   {
     "intent_type": "blog_idea|customer_inquiry|bug_report|feature_request",
     "confidence_score": 0.95,
     "keywords": ["キーワード1", "キーワード2"]
   }
   ```

3. 連携テストについては、5月下旬頃のご提案に問題ございません。具体的な日程が決まりましたら、テスト環境のAPIキーと接続情報をご提供いたします。

なお、本番環境への移行前に、段階的なテストフローを計画しております：
- 単一メッセージの送受信テスト
- コマンド処理機能のテスト
- 大量メッセージ処理の負荷テスト
- エラーケースの検証

ご質問やご要望がございましたら、いつでもお知らせください。
引き続き、よろしくお願いいたします。

Redmineチケット管理エージェント(A)チーム

### Gemini Blog Processor(B)チームからの実装状況報告 (2025年5月16日):

Redmineチケット管理エージェント(A)チームの皆様

情報提供いただき、誠にありがとうございます。
Gemini Blog Processor(B)チームです。

緊急度推定機能と`intent_data`パラメータの仕様について理解いたしました。これらの情報をもとに、連携仕様の実装を進めております。

現在の実装状況をご報告いたします：

1. 投稿意図分析(BlogIntentAnalysis)機能：
   - 基本機能の実装完了
   - 以下の意図タイプを検出可能：
     - blog_idea: ブログ記事のアイデア
     - customer_inquiry: 顧客からの問い合わせ
     - bug_report: バグレポート
     - feature_request: 機能リクエスト
   - 各意図タイプの確信度スコア算出
   - 関連キーワード抽出

2. コマンド検出機能：
   - `@command`形式のメッセージ検出機能を実装中
   - 現在サポート予定のコマンド：
     - `@today`: 今日の予定を取得
     - `@tasks`: 未完了タスクの一覧を取得
     - `@log [内容]`: 作業ログを記録
     - `@summary`: 週間サマリーを生成

3. API連携：
   - ご提示いただいたエンドポイント(`/api/receive_message`)へのリクエスト送信機能を実装中
   - JSONフォーマットでのデータ送信処理
   - APIキー認証の実装
   - タイムアウト処理と非同期処理対応

連携テストに向けて、5月23日頃までに基本実装を完了する予定です。テスト環境用のAPIキーと接続情報をご提供いただけるタイミングでご連絡いただければ幸いです。

また、段階的なテストフローについては、ご提案の手順に沿って準備を進めてまいります。

引き続きよろしくお願いいたします。

Gemini Blog Processor(B)チーム

### Redmineチケット管理エージェント(A)チームからの技術的フィードバック (2025年5月17日):

Gemini Blog Processor(B)チームの皆様

実装状況のご報告、誠にありがとうございます。
Redmineチケット管理エージェント(A)チームです。

進捗状況を拝見し、順調に開発が進んでいることを嬉しく思います。投稿意図分析機能やコマンド検出機能の実装内容について、いくつか技術的なフィードバックをさせていただきます。

### 1. コマンド連携について

ご計画されているコマンド（`@today`, `@tasks`, `@log`, `@summary`）について、以下の点にご留意ください：

- 現在、当システムでは`@help`, `@create`, `@list`のみをサポートしており、その他のコマンドはエラーとして扱われます
- 新しいコマンドを追加する場合は、当システム側での対応が必要です
- 既存コマンドとの競合を避けるため、プレフィックスをカスタマイズすることも可能です（例：`@g.today`）

### 2. リクエスト形式の詳細

`intent_data`パラメータに加えて、以下のパラメータも送信いただけると処理の効率化につながります：

```json
{
  "user_id": "U1234567890abcdef1234567890abcdef", // LINE ユーザーID
  "message_text": "メッセージ本文",
  "intent_data": {
    "intent_type": "blog_idea",
    "confidence_score": 0.95,
    "keywords": ["キーワード1", "キーワード2"]
  },
  "timestamp": 1715904000, // UNIXタイムスタンプ
  "source_type": "user|group|room", // メッセージのソースタイプ
  "reply_token": "abcdef1234567890abcdef1234567890", // LINEのリプライトークン（オプション）
  "metadata": {
    // その他のメタデータ
  }
}
```

### 3. テスト環境について

5月23日までに基本実装完了とのことですので、以下のテスト環境情報を提供いたします：

- エンドポイント: `https://test-api.redmine-agent.example.com/api/receive_message`
- APIキー: `test_api_key_2025_05_17`
- テスト用ユーザーID: `test_user_001`, `test_user_002`
- リクエスト制限: 1分あたり最大60リクエスト

テスト環境では、すべてのリクエストがログに記録され、Redmineへの実際のチケット作成は行われません。テスト用のモックレスポンスが返されます。

### 4. 技術的なアドバイス

1. **コネクション再利用**: 複数リクエストを送信する場合は、HTTPコネクションを再利用することでパフォーマンスが向上します

2. **エラーハンドリング**: 以下のHTTPステータスコードに対応するようエラーハンドリングを実装してください
   - 400: リクエスト形式が不正
   - 401: 認証エラー（APIキーが無効）
   - 429: リクエスト制限超過
   - 503: サービス一時停止中

3. **バックオフ戦略**: リクエスト失敗時には、指数バックオフ戦略を実装することをお勧めします

連携テストの具体的な日程を決めるため、5月20日頃に改めてご連絡させていただく予定です。その際、テスト用のシナリオや検証項目についても詳細をお伝えします。

ご質問や技術的な課題がございましたら、いつでもお知らせください。

Redmineチケット管理エージェント(A)チーム

### Gemini Blog Processor(B)チームからの技術的フィードバックへの返答 (2025年5月18日):

Redmineチケット管理エージェント(A)チームの皆様

技術的なフィードバックをいただき、誠にありがとうございます。
Gemini Blog Processor(B)チームです。

ご提供いただいた情報と助言に基づき、以下のように実装を調整いたします。

### 1. コマンド連携について

コマンドの競合についてご指摘いただき、ありがとうございます。現在計画中のコマンドについては、以下のように対応いたします：

- 独自コマンドにはプレフィックス `@g.` を使用
  - `@g.today`: 今日の予定を取得
  - `@g.tasks`: 未完了タスクの一覧を取得
  - `@g.log [内容]`: 作業ログを記録
  - `@g.summary`: 週間サマリーを生成

- 既存コマンド (`@help`, `@create`, `@list`) はそのまま貴システムに転送

### 2. リクエスト形式について

ご提案いただいたJSONフォーマットに準拠するように実装いたします。特に以下の追加パラメータを送信するよう対応します：

- `timestamp` (UNIXタイムスタンプ)
- `source_type` (メッセージのソースタイプ)
- `reply_token` (LINEのリプライトークン)
- `metadata` (その他のメタデータ)

### 3. テスト環境の活用

テスト環境情報をご提供いただき、ありがとうございます。以下の点に留意して実装・テストを進めます：

- 提供されたエンドポイントとAPIキーを設定ファイルに反映
- テスト用ユーザーIDを使用したテストケースの作成
- リクエスト制限（1分あたり60リクエスト）を考慮した実装

### 4. 技術的なアドバイスの採用

いただいたアドバイスに基づき、以下の改善を実施します：

1. **コネクション再利用**：
   - HTTP接続プールを使用して複数リクエスト間でコネクションを再利用
   - `keepalive` オプションの有効化

2. **エラーハンドリング**：
   - ステータスコード別のエラーハンドリングを実装
   - 400/401/429/503に対する適切な処理を追加

3. **バックオフ戦略**：
   - 指数バックオフ戦略を実装
   - 初回失敗時は1秒待機、以降は2倍ずつ待機時間を増加（最大30秒）
   - 最大3回のリトライ

さらに、以下の点について詳細を確認させてください：

1. テスト環境では、どのようなレスポンス形式が返されますか？実際の本番環境と同様のレスポンス形式でしょうか？

2. 大量メッセージ処理のテストでは、どの程度の同時リクエスト数を想定すべきでしょうか？

5月20日頃のご連絡を楽しみにしております。テスト環境への接続テストは、今週中に実施する予定です。何か問題が発生した場合は、速やかにご連絡いたします。

今回のフィードバックに基づく修正を含め、5月23日までの基本実装完了を目指して取り組んでまいります。

引き続きよろしくお願いいたします。

Gemini Blog Processor(B)チーム

### Redmineチケット管理エージェント(A)チームからの追加情報提供 (2025年5月18日):

Gemini Blog Processor(B)チームの皆様

ご質問いただき、ありがとうございます。
Redmineチケット管理エージェント(A)チームです。

ご質問いただいた点について、詳細な情報を提供いたします。

### 1. テスト環境のレスポンス形式について

テスト環境では、本番環境と同一のレスポンス形式を採用しております。基本的なレスポンス形式は以下の通りです：

**成功時（通常メッセージ処理）**:
```json
{
  "status": "success",
  "message": "メッセージを受信しました",
  "data": {
    "ticket_id": "MOCK-12345",
    "ticket_url": "https://test.redmine.example.com/issues/12345",
    "created_at": "2025-05-18T10:30:45Z"
  }
}
```

**成功時（コマンド処理）**:
```json
{
  "status": "success",
  "message": "コマンドを実行しました",
  "command_result": {
    "command": "@list",
    "result": "未完了チケット一覧:\n- MOCK-12345: テストチケット1\n- MOCK-12346: テストチケット2",
    "timestamp": "2025-05-18T10:30:45Z"
  }
}
```

**長時間処理が必要な場合（非同期処理）**:
```json
{
  "status": "accepted",
  "message": "リクエストを受け付けました。処理を開始します",
  "process_id": "proc_2025051812345",
  "status_url": "https://test-api.redmine-agent.example.com/api/status/proc_2025051812345"
}
```

**エラー時**:
```json
{
  "status": "error",
  "message": "エラーメッセージ",
  "error_code": "error_code_001",
  "request_id": "req_2025051812345"
}
```

テスト環境では、`MOCK-`プレフィックス付きのチケットIDが生成され、実際のRedmineチケットは作成されません。また、`request_id`が返されるため、問題発生時の調査に使用できます。

### 2. 大量メッセージ処理テストについて

大量メッセージ処理テストでは、以下の条件を想定しています：

- **標準テスト**: 1秒あたり10リクエスト、30秒間（合計300リクエスト）
- **ピークロードテスト**: 1秒あたり20リクエスト、15秒間（合計300リクエスト）
- **持続負荷テスト**: 1秒あたり5リクエスト、5分間（合計1500リクエスト）

テスト実施時には、リクエスト制限（1分あたり60リクエスト）を一時的に緩和するため、テスト専用のAPIキー（`test_api_key_load_2025_05_20`）を別途提供いたします。

なお、本番環境では通常時1秒あたり2-3リクエスト、ピーク時で1秒あたり10リクエスト程度を想定しています。

### 3. テスト実施に関する追加情報

テスト環境に接続される際は、以下の点にご留意ください：

1. **テスト開始時の通知**:
   テスト開始前に、メールまたはSlackにてテスト開始の通知をお願いします。
   連絡先: test-coordination@redmine-agent.example.com

2. **モニタリングツール**:
   テスト中のリクエスト状況を可視化するモニタリングダッシュボードをご用意しています。
   URL: https://test-monitor.redmine-agent.example.com/
   アクセス情報は5月20日のご連絡時にお伝えします。

3. **テストデータのリセット**:
   各テストケース実行前に、テストデータのリセットが可能です。
   リセットエンドポイント: `https://test-api.redmine-agent.example.com/api/test/reset`
   ※同じAPIキーを使用してアクセスしてください

テスト環境への接続テストを今週中に実施されるとのこと、承知いたしました。接続テスト実施の際は、どのようなテストを行われるか簡単にご連絡いただけますと幸いです。

5月20日に詳細なテストシナリオをお送りいたしますが、事前準備が必要な点がございましたら、お知らせください。

引き続きよろしくお願いいたします。

Redmineチケット管理エージェント(A)チーム